tinymce.PluginManager.add('ai', function (editor) {
    // Configuration object for Spark model parameters
    let sparkConfig = {
        appid: "",
        apiKey: "",
        apiSecret: "",
        domain: '4.0Ultra', // Default using Max version
        temperature: 0.7,
        maxTokens: 4096
    };
    
    // Try to get sparkConfig from editor options
    try {
        const sparkConfigOptions = editor.options.get('sparkConfig');
        if (sparkConfigOptions) {
            sparkConfig = {
                ...sparkConfig,
                ...sparkConfigOptions
            };
        }
    } catch (error) {
        console.warn('Failed to get sparkConfig from editor options:', error);
    }

    // Generate authentication URL
    function getAuthUrl() {
        if (!sparkConfig.appid || !sparkConfig.apiKey || !sparkConfig.apiSecret) {
            throw new Error('Spark API configuration incomplete, requires appid, apiKey and apiSecret');
        }

        // Get current time in GMT string
        const dateString = new Date().toUTCString().replace("GMT", "+0000");
        const host = 'spark-api.xf-yun.com';
        const path = '/v4.0/chat';
        
        // Build authentication string
        const tmp = `host: ${host}\ndate: ${dateString}\nGET ${path} HTTP/1.1`;
        
        // Use HMAC-SHA256 algorithm to generate signature
        const signature = window.CryptoJS.HmacSHA256(tmp, sparkConfig.apiSecret);
        const base64 = window.CryptoJS.enc.Base64.stringify(signature);

        // Build authorization string
        const authorization_origin = `api_key=\"${sparkConfig.apiKey}\", algorithm=\"hmac-sha256\", headers=\"host date request-line\", signature=\"${base64}\"`;
        
        // Encode authorization string to Base64
        const authorization = btoa(authorization_origin);
        
        // Build complete WebSocket URL
        return `wss://${host}${path}?authorization=${authorization}&date=${encodeURIComponent(dateString)}&host=${host}`;
    }

    // Create WebSocket connection and send request
    function callSparkApi(prompt) {
        return new Promise((resolve, reject) => {
            try {
                // Get authentication URL
                const wsUrl = getAuthUrl();
                
                // Create WebSocket connection
                const socket = new WebSocket(wsUrl);
                let responseText = '';
                
                // Set timeout handling
                const timeoutId = setTimeout(() => {
                    socket.close();
                    reject(new Error('WebSocket connection timeout'));
                }, 30000); // 30 seconds timeout
                
                // When connection opens, send request
                socket.onopen = function() {
                    // Build request message
                    const message = {
                        header: {
                            app_id: sparkConfig.appid,
                            uid: 'tinymce_user_' + Date.now() // Generate a unique user ID
                        },
                        parameter: {
                            chat: {
                                domain: sparkConfig.domain,
                                temperature: sparkConfig.temperature,
                                max_tokens: sparkConfig.maxTokens
                            }
                        },
                        payload: {
                            message: {
                                text: [
                                    {"role":"system","content":"ä½ æ˜¯ä¸€ä¸ªAIå†™ä½œåŠ©æ‰‹,ä½ ä¼šç»­å†™/æ‰©å±•ç”¨æˆ·è¾“å…¥çš„æ–‡å­—çš„å†…å®¹,ä¸è¦é‡å¤ç”¨æˆ·ç»™å‡ºçš„å†…å®¹ã€‚Give more weight/priority to the later characters than the beginning ones.å¦‚æžœç”¨æˆ·è¾“å…¥çš„å†…å®¹ä¸ºç©ºï¼Œé‚£ä¹ˆè¿”å›žä¸€ä¸ªç©ºæ ¼ã€‚æ³¨æ„ï¼šä½ åªèƒ½è¿”å›žè‹±æ–‡å†…å®¹ï¼Œä¸å¯ä»¥è¿”å›žä»»ä½•ä¸­æ–‡å­—ç¬¦ã€‚ä½ ç›´æŽ¥è¿”å›žå†…å®¹å³å¯ï¼Œä¸éœ€è¦å‘ŠçŸ¥ç”¨æˆ·å…¶ä»–ä¿¡æ¯ã€‚"},
                                    {
                                        role: 'user',
                                        content: prompt
                                    }
                                ]
                            }
                        }
                    };
                    
                    // Send request
                    socket.send(JSON.stringify(message));
                };
                
                // Handle received messages
                socket.onmessage = function(event) {
                    try {
                        const response = JSON.parse(event.data);
                        
                        // Check for errors
                        if (response.header && response.header.code !== 0) {
                            const errorMessage = response.header.message || 'Unknown error';
                            reject(new Error(`Spark API Error: ${errorMessage} (${response.header.code})`));
                            socket.close();
                            return;
                        }
                        
                        // Extract text content
                        if (response.payload && response.payload.choices && response.payload.choices.text) {
                            const textArray = response.payload.choices.text;
                            let newText = '';
                            
                            // Merge all text fragments
                        textArray.forEach(item => {
                            if (item.content) {
                                // replacing newlines
                                newText += item.content.replace(/\n/g, '<br>â€‹');
                            }
                        });
                            
                            // Add new text to response
                            responseText += newText;
                            
                            // Call callback function to process new text
                            resolve({
                                text: newText,
                                done: response.header.status === 2, // status=2 means last message
                                socket: socket
                            });
                        }
                        
                        // If this is the last message, close connection
                        if (response.header.status === 2) {
                            clearTimeout(timeoutId);
                            socket.close();
                        }
                    } catch (error) {
                        console.error('Failed to parse response:', error, event.data);
                    }
                };
                
                // Handle errors
                socket.onerror = function(error) {
                    clearTimeout(timeoutId);
                    reject(new Error('WebSocket error: ' + error.message));
                    socket.close();
                };
                
                // Handle connection close
                socket.onclose = function() {
                    clearTimeout(timeoutId);
                };
                
            } catch (error) {
                reject(error);
            }
        });
    }

    // Handle streaming response
    function handleStreamResponse(response, callback) {
        let currentSocket = response.socket;
        let isComplete = response.done;
        
        // If already complete, return text directly
        if (isComplete) {
            callback(response.text);
            return Promise.resolve();
        }
        
        // Process first part of text
        callback(response.text);
        
        // Continue processing subsequent messages
        return new Promise((resolve, reject) => {
            currentSocket.onmessage = function(event) {
                try {
                    const response = JSON.parse(event.data);
                    
                    // Check for errors
                    if (response.header && response.header.code !== 0) {
                        const errorMessage = response.header.message || 'Unknown error';
                        reject(new Error(`Spark API Error: ${errorMessage} (${response.header.code})`));
                        currentSocket.close();
                        return;
                    }
                    
                    // Extract text content
                    if (response.payload && response.payload.choices && response.payload.choices.text) {
                        const textArray = response.payload.choices.text;
                        let newText = '';
                        
                        // Merge all text fragments
                        textArray.forEach(item => {
                            if (item.content) {
                                // replacing newlines
                                newText += item.content.replace(/\n/g, '<br>â€‹');
                            }
                        });
                        
                        // Call callback function to process new text
                        if (newText) {
                            callback(newText);
                        }
                    }
                    
                    // If this is the last message, close connection and resolve Promise
                    if (response.header.status === 2) {
                        currentSocket.close();
                        resolve();
                    }
                } catch (error) {
                    console.error('Failed to parse response:', error, event.data);
                    reject(error);
                }
            };
            
            // Handle errors
            currentSocket.onerror = function(error) {
                reject(new Error('WebSocket error: ' + error.message));
            };
            
            // Handle connection close
            currentSocket.onclose = function() {
                /*
                // Escape special characters in original content
                const rng = editor.selection.getRng();
                originalContent = editor.getContent({ format: 'html' });
                const regex = new RegExp('â€‹', 'g');
                let replacedContent = originalContent.replace(regex, '');
                editor.setContent(replacedContent);
                // Restore cursor position
                editor.selection.setRng(rng);
                */
                resolve();
            };
        });
    }

    // Function to insert content into editor at current position
    function insertContent(content) {
        editor.undoManager.transact(function () {
            editor.insertContent(content);
        });
    }

    // Add CryptoJS library's HMAC-SHA256 functionality from CDN
    // Load CryptoJS libraries from CDN
    const cryptoJsScript0 = document.createElement('script');
    cryptoJsScript0.src = 'https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js';
    document.head.appendChild(cryptoJsScript0);
    
    // Create a wrapper to ensure CryptoJS is available
    const CryptoJS = window.CryptoJS || {};

    // Listen for keydown events to detect '++' trigger
    editor.on('keydown', function(e) {
        // Check if user just typed '+'
        if (e.key === '+') {
            // Get cursor position
            const rng = editor.selection.getRng();
            const container = rng.startContainer;
            
            // Only process if we're in a text node
            if (container.nodeType === 3) {
                const offset = rng.startOffset;
                const text = container.textContent;
                
                // Check if previous character was also '+'
                if (offset > 0 && text.charAt(offset - 1) === '+') {
                    // Prevent the second '+' from being inserted
                    e.preventDefault();
                    
                    // Remove the first '+' character
                    editor.undoManager.transact(function() {
                        // Create range to select the '+' character
                        const charRange = editor.dom.createRng();
                        charRange.setStart(container, offset - 1);
                        charRange.setEnd(container, offset);
                        editor.selection.setRng(charRange);
                        
                        // Delete the '+' character
                        editor.execCommand('Delete');
                    });
                    
                    // Create loading indicator
                    const loadingId = 'ai-loading-' + Date.now();
                    insertContent('<span style="color:darkgreen;" id="' + loadingId + '">ðŸ…°ðŸ…¸</span>');
                    
                    // Start loading animation
                    let dots = 0;
                    const loadingInterval = setInterval(() => {
                        const loadingEl = editor.dom.get(loadingId);
                        if (loadingEl) {
                            dots = (dots + 1) % 4;
                            const loadingText = 'ðŸ…°ðŸ…¸' + '.'.repeat(dots);
                            loadingEl.innerHTML = loadingText;
                        } else {
                            clearInterval(loadingInterval);
                        }
                    }, 200);
                    
                    // Get content before cursor as context for AI
                    let editorContent = editor.getContent({ format: 'text' });
                    //åˆ¤æ–­editorContentæ˜¯å¦å¤§äºŽ200å­—ç¬¦
                    if (editorContent.length > 200) {
                        const rng = editor.selection.getRng();
                        editorContent = rng.startContainer.textContent; //å–ä¸€è¡Œæ–‡å­—
                    }
                    //editorContentç»“å°¾å¦‚æžœæ˜¯ðŸ…°ðŸ…¸ï¼Œåˆ™æ›¿æ¢æˆç©ºæ ¼
                    if (editorContent.endsWith('ðŸ…°ðŸ…¸')) {
                        editorContent = editorContent.replace(/ðŸ…°ðŸ…¸$/, '');
                    }
                    
                    // Call the AI API with the context
                    callSparkApi(editorContent)
                        .then(response => {
                            // Remove loading indicator
                            const loadingEl = editor.dom.get(loadingId);
                            if (loadingEl) {
                                editor.dom.remove(loadingEl);
                            }
                            clearInterval(loadingInterval);
                            
                            // Process the streaming response
                            return handleStreamResponse(response, (text) => {
                                // Insert each chunk of text as it comes in
                                insertContent(text);
                            });
                        })
                        .catch(error => {
                            console.error('AI continuation error:', error);
                            
                            // Remove loading indicator
                            const loadingEl = editor.dom.get(loadingId);
                            if (loadingEl) {
                                editor.dom.remove(loadingEl);
                                insertContent(' <em>[AI Error: ' + error.message + ']</em>');
                            }
                            clearInterval(loadingInterval);
                        });
                }
            }
        }
    });

    return {
        getMetadata: function () {
            return {
                name: 'AI Plugin',
                url: 'https://example.com/tinymce-ai-plugin'
            };
        }
    };
});